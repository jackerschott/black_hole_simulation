#version 320 es

#include "math.glsl"
#include "complex.glsl"
#include "elliptic.glsl"
#include "geodesic.glsl"

#include "transf.glsl"

precision mediump image2D;

layout(location = 0) uniform vec4 cPos;
layout(location = 1) uniform mat2 P_I;
layout(location = 2) uniform mat4 V_I;
layout(location = 3) uniform uvec2 srcSize;
layout(location = 4, binding = 0, rgba32f) readonly uniform image2D texSrc;
layout(location = 5, binding = 1, rgba32f) writeonly uniform image2D texDst;

layout(local_size_x = 8, local_size_y = 8) in;
void main() {
  // Get invocation details
  uvec2 g = gl_GlobalInvocationID.xy;
  uvec2 size = gl_NumWorkGroups.xy * gl_WorkGroupSize.xy;

  // Create rotation matrices to reduce the computations to the xy-plane
  // R  : Inverse of R_I
  // R_I : Rotates cPos and pos to the xy-plane
  vec2 pos = 2.0 * vec2(g) / vec2(size - 1u) - 1.0;
  vec4 l = V_I * vec4(P_I * pos, -1.0, 1.0);
  vec3 n = normalize(cross(cPos.xyz, (cPos + l).xyz));
  
  mat4 R_I = rot(vec3(n.y, -n.x, 0.0), acos(n.z));
  mat4 R = transpose(R_I);

  // Create initial values for a geodesic (initial point and impact param)
  vec2 p = (R_I * cPos).xy;
  vec2 v = (R_I * l).xy;
  float u1 = 1.0 / length(p);
  float phi1 = atan(p.y, p.x);

  float b = v2b(v, u1, phi1);
  if (b <= bc) {
    imageStore(texDst, ivec2(g), vec4(0.0, 0.0, 0.0, 1.0));
    return;
  }

  // Compute angle at infinity from initial values
  vec2 R1, R2, R3;
  roots(b, R1, R2, R3);
  float phi2 = phi_plus_ext(0.0, b, u1, phi1, R1, R2, R3).x;

  // Get spherical coordinates phi and theta in 3D from 2D angle
  vec4 esc = R * vec4(cos(phi2), sin(phi2), 0.0, 1.0);
  float phi = atan(esc.y, esc.x);
  float theta = acos(esc.z);

  // Take color from the sphere's texture at the intersection point and write it to result
  ivec2 texCoord = ivec2(vec2(0.5 + phi / PI2, theta / PI) * vec2(srcSize));
  // ivec2 texCoord = ivec2(P_I * pos * vec2(srcSize));
  vec4 color = imageLoad(texSrc, texCoord);
  imageStore(texDst, ivec2(g), color);
}
